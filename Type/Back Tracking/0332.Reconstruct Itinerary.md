# LC 332. Reconstruct Itinerary

Description:

You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.

All of the tickets belong to a man who departs from "JFK", thus, the itinerary must begin with "JFK". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

Example 1:

```
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
```

## Step by step:
1. 首次调用backtracking(4, 2, 1)：

    * for循环开始于i=1。
    * path变为[1]。
    * 递归调用backtracking(4, 2, 2)，因为我们不想再次使用数字1。
2. 再次调用backtracking(4, 2, 2)：

    * for循环开始于i=2。
    * path变为[1, 2]。
    * 我们找到了一个长度为k（2）的组合，所以我们将其添加到result中：result = [[1, 2]]。
    * path.pop()使得path回退到[1]。
    * 回到backtracking(4, 2, 2)的循环，i增加到3：

    * path变为[1, 3]。
    * 又是一个长度为k的组合，添加到result中：result = [[1, 2], [1, 3]]。
    * path.pop()使得path回退到[1]。
    * 回到backtracking(4, 2, 2)的循环，i增加到4：

    * path变为[1, 4]。
    * 又是一个长度为k的组合，添加到result中：result = [[1, 2], [1, 3], [1, 4]]。
    * path.pop()使得path回退到[1]。
    * 现在，backtracking(4, 2, 2)的循环完成，我们回到了最初的backtracking(4, 2, 1)调用，并且path已经回退到[]。

接下来的步骤是从数字2开始尝试新的组合。我们已经用过数字1，现在是i=2的轮次：


Ans:

```py
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        path = []
        def backtracking(n, k, starting_idx):            
            if len(path) == k:
                result.append(path[:])
                return
            for i in range(starting_idx, n+1):
                path.append(i)
                backtracking(n, k, i+1)
                path.pop()
        backtracking(n,k,1)
        return result


```