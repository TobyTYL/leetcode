# 算法时空复杂度分析实用指南

## 1. 借助复杂度反推解题思路

举例来说吧，比如一个题目给你输入一个数组，其长度能够达到 10^6 这个量级，那么我们肯定可以知道这道题的时间复杂度大概要小于 O(N^2)，得优化成 O(NlogN) 或者 O(N) 才行。因为如果你写的算法是 O(N^2) 的，最大的复杂度会达到 10^12 这个量级，在大部分判题系统上都是跑不过去的。

如果你发现题目给的数据规模很小，比如数组长度 N 不超过 20 这样的，那么我们可以断定这道题大概率要用暴力穷举算法, 例如回溯算法。

## 2. Big O 表示法

#### 1. 只保留增长速率最快的项，其他的项可以省略。
```
O(N^3 + 999 * N^2 + 999 * N) = O(N^3)
O((N + 1) * 2^N) = O(N * 2^N + 2^N) = O(N * 2^N)
```

#### 2. Big O 记号表示复杂度的「上界」。

<img src = "https://labuladong.online/algo/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg">

这棵树上共有多少节点？都按最坏情况来处理，高度为 N 的一棵满 K 叉树，其节点总数为等比数列求和公式 (K^N - 1)/(K - 1)，用 Big O 表示就是 O(K^N)。



#### 3. 非递归算法分析

* 重点在于指针不回退
    * 仔细看滑动窗口的算法框架，你只看到了 left++ 和 right++，有没有看到 left-- 或者 right--？没有。这就叫指针不回退，所以时间复杂度是线性的 O(N)。
* 滑动窗口算法框架

```python
def slidingWindow(s: str):
    window = {}
    # 双指针，维护 [left, right) 为窗口
    left = 0
    right = 0
    while right < len(s):
        # 增大窗口
        right += 1
        # 判断左侧窗口是否要收缩
        while window_needs_shrink():
            # 缩小窗口
            left += 1
```

* 一般的嵌套 for 循环: 这个 j，它在外层循环 i 的每一次迭代中都会回退到 0 重新开始，所以这种嵌套循环的时间复杂度就是 O(N^2)。




```java
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        // ...
    }
}
```
