## 98. Validate Binary Search Tree

Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

* The left subtree of a node contains only nodes with keys less than the node's key.
* The right subtree of a node contains only nodes with keys greater than the node's key.
* Both the left and right subtrees must also be binary search trees.

Example 1:


<img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="My Image" height="250" />

```
Input: root = [2,1,3]
Output: true
```

## Ideal:

* 中序遍历下，输出的二叉搜索树节点的数值是有序序列。
* 有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。
* 然后比较一下，这个数组是否是有序的，注意二叉搜索树中不能有重复元素。



### Solution:

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.vec = []

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        self.vec = []  # 清空数组
        self.traversal(root)
        for i in range(1, len(self.vec)):
            # 注意要小于等于，搜索树里不能有相同元素
            if self.vec[i] <= self.vec[i - 1]:
                return False
        return True

    def traversal(self, root):
        if root is None:
            return
        self.traversal(root.left)
        self.vec.append(root.val)  # 将二叉搜索树转换为有序数组
        self.traversal(root.right)
```